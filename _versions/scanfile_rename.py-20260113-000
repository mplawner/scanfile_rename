import sys, subprocess, os, json, re, base64, tempfile, shutil, argparse
from datetime import datetime

LM_STUDIO_ENDPOINT=os.getenv("LM_STUDIO_ENDPOINT","http://localhost:1234/v1/chat/completions")
MODEL_NAME=os.getenv("LM_STUDIO_MODEL","qwen3-vl-8b-instruct")
PDFTOTEXT=os.getenv("PDFTOTEXT","/opt/homebrew/bin/pdftotext")
PDFTOPPM=os.getenv("PDFTOPPM","/opt/homebrew/bin/pdftoppm")

VISION_MAX_PAGES=int(os.getenv("VISION_MAX_PAGES","3"))
VISION_DPI=int(os.getenv("VISION_DPI","200"))
MIN_TEXT_CHARS=int(os.getenv("MIN_TEXT_CHARS","200"))

def _run(cmd): return subprocess.run(cmd, capture_output=True, text=True)

def _extract_json_loose(s):
    s=(s or "").strip()
    try: return json.loads(s)
    except: pass
    i=s.find("{"); j=s.rfind("}")
    if i!=-1 and j!=-1 and j>i:
        try: return json.loads(s[i:j+1])
        except: return None
    return None

def _img_to_data_url(path):
    b=base64.b64encode(open(path,"rb").read()).decode("utf-8")
    return f"data:image/jpeg;base64,{b}"

def _pdftotext(pdf_input):
    r=_run([PDFTOTEXT, pdf_input, "-"])
    if r.returncode != 0: return ""
    return (r.stdout or "").strip()

def _render_pdf_to_images(pdf_input, max_pages=VISION_MAX_PAGES, dpi=VISION_DPI):
    with tempfile.TemporaryDirectory(prefix="scan_vlm_") as td:
        prefix=os.path.join(td, "page")
        r=_run([PDFTOPPM, "-f","1","-l",str(max_pages),"-r",str(dpi),"-jpeg", pdf_input, prefix])
        if r.returncode != 0:
            raise RuntimeError(r.stderr.strip() or r.stdout.strip() or "pdftoppm failed")
        imgs=sorted([os.path.join(td,f) for f in os.listdir(td) if f.startswith("page-") and f.endswith(".jpg")],
                    key=lambda p: int(re.search(r"-(\d+)\.jpg$", p).group(1)))
        if not imgs: raise RuntimeError("No images produced from PDF")
        return [_img_to_data_url(p) for p in imgs]

def _is_context_overflow(err):
    s=str(err or "").lower()
    return ("context length" in s) or ("overflows" in s) or ("not enough" in s) or ("overflow" in s)

def _clean_err(resp):
    try:
        j=resp.json()
        return j.get("error") or j
    except Exception:
        return (resp.text or "").strip()

def _call_lm_studio(messages, max_tokens=350, timeout=120):
    import requests
    payload={"model":MODEL_NAME,"messages":messages,"temperature":0.0,"max_tokens":max_tokens}
    try:
        resp=requests.post(LM_STUDIO_ENDPOINT, headers={"Content-Type":"application/json"}, json=payload, timeout=timeout)
    except requests.RequestException as e:
        return None, f"RequestException: {e}"
    if resp.status_code >= 400:
        return None, _clean_err(resp)
    try:
        j=resp.json()
        return j["choices"][0]["message"]["content"], None
    except Exception as e:
        return None, f"BadResponse: {e} | body={(resp.text or '')[:2000]}"

def _compact_text(text, max_chars):
    t=(text or "").strip()
    if len(t) <= max_chars: return t
    lines=[ln.strip() for ln in t.splitlines() if ln.strip()]
    if not lines: return t[:max_chars]
    pats=[
        r"\b\d{1,2}/\d{1,2}/\d{2,4}\b",
        r"\b\d{4}-\d{2}-\d{2}\b",
        r"\b(jan|feb|mar|apr|may|jun|jul|aug|sep|sept|oct|nov|dec)[a-z]*\b",
        r"\b(invoice|statement|receipt|bill|balance|amount|total|due|paid|payment|account|acct|order|purchase)\b",
        r"\b(service|date of service|dos|appointment|visit|delivered|shipped)\b",
        r"\b(policy|contract|agreement|notice|letter|form|report|summary|renewal)\b",
        r"\b(tax|irs|1099|w-2|utility|electric|gas|water|internet|insurance|mortgage|bank|credit)\b",
    ]
    rx=re.compile("|".join(pats), re.I)
    picked=[ln for ln in lines if rx.search(ln)]
    s="\n".join(picked)
    if len(s) >= max_chars: return s[:max_chars]
    head="\n".join(lines[:250])
    tail="\n".join(lines[-250:])
    combo=(s+"\n\n"+head+"\n\n"+tail).strip()
    return combo[:max_chars]

def _normalize_date(s):
    if not s: return None
    s=str(s).strip()
    try:
        datetime.strptime(s, "%Y-%m-%d")
        return s
    except: return None

def _normalize_doc_type(s):
    if not s: return None
    s=re.sub(r"\s{2,}"," ",str(s)).strip()
    s=re.sub(r"[^A-Za-z0-9 &/+-]","",s).strip()
    if not s: return None
    low=s.lower()
    m={
        "invoice":"Invoice","inv":"Invoice",
        "statement":"Statement",
        "receipt":"Receipt",
        "bill":"Bill",
        "report":"Report",
        "letter":"Letter",
        "notice":"Notice",
        "contract":"Contract","agreement":"Agreement",
        "policy":"Policy",
        "form":"Form",
        "summary":"Summary",
        "tax":"Tax Document",
    }
    for k,v in m.items():
        if re.search(rf"\b{re.escape(k)}\b", low): return v
    return " ".join(w.capitalize() for w in s.split())[:40]

def _unknown_count(info):
    info=info or {}
    c=0
    if not _normalize_date(info.get("date")): c+=1
    if not (info.get("provider") and str(info.get("provider")).strip()): c+=1
    if not _normalize_doc_type(info.get("document_type")): c+=1
    t=str(info.get("title") or "").strip()
    if len(t) < 3: c+=1
    return c

def _merge_fill_missing(base, extra):
    base=dict(base or {})
    extra=extra or {}
    # date
    if not _normalize_date(base.get("date")) and _normalize_date(extra.get("date")):
        base["date"]=extra.get("date")
    # simple string fields
    for k in ["date_basis","provider","document_type","title"]:
        if not (base.get(k) and str(base.get(k)).strip()) and (extra.get(k) and str(extra.get(k)).strip()):
            base[k]=extra.get(k)
    # confidence
    try:
        bc=float(base.get("confidence") or 0)
    except: bc=0
    try:
        ec=float(extra.get("confidence") or 0)
    except: ec=0
    base["confidence"]=max(bc, ec)
    return base

def _safe_filename(s, max_len=80):
    s=re.sub(r'[\r\n\t]+',' ',str(s or ""))
    s=re.sub(r'[\/\\:\*\?"<>\|]+','-',s)
    s=re.sub(r"\s{2,}"," ",s).strip()
    s=s.strip(" .-_")
    return (s[:max_len] or "")

def _unique_path(path):
    if not os.path.exists(path): return path
    root, ext=os.path.splitext(path)
    for i in range(2, 200):
        p=f"{root} ({i}){ext}"
        if not os.path.exists(p): return p
    return f"{root} ({os.getpid()}){ext}"

def _heuristic_extract(text):
    lines=[ln.strip() for ln in (text or "").splitlines() if ln.strip()]
    top=lines[:60]
    date=None
    for ln in top:
        m=re.search(r"\b(\d{4}-\d{2}-\d{2})\b", ln)
        if m: date=m.group(1); break
    if not date:
        for ln in top:
            m=re.search(r"\b(\d{1,2})/(\d{1,2})/(\d{2,4})\b", ln)
            if not m: continue
            mm,dd,yy=m.group(1),m.group(2),m.group(3)
            yy=("20"+yy) if len(yy)==2 else yy
            try:
                d=datetime(int(yy),int(mm),int(dd))
                date=d.strftime("%Y-%m-%d")
                break
            except: pass
    provider=None
    for ln in top[:15]:
        if len(ln) >= 4 and not re.search(r"page\s+\d+", ln, re.I):
            if re.search(r"[A-Za-z]", ln):
                provider=ln
                break
    blob="\n".join(top).lower()
    dt=None
    for k,v in [("invoice","Invoice"),("statement","Statement"),("receipt","Receipt"),("bill","Bill"),("report","Report"),
                ("contract","Contract"),("agreement","Agreement"),("policy","Policy"),("notice","Notice"),("letter","Letter"),("form","Form")]:
        if k in blob: dt=v; break
    title=None
    for ln in top[:20]:
        if re.search(r"\b(invoice|statement|receipt|bill|report|contract|agreement|policy|notice|letter|form)\b", ln, re.I):
            title=ln
            break
    return {"date":date,"date_basis":"unknown","provider":provider,"document_type":dt,"title":title,"confidence":0.25}

def extract_information(pdf_input):
    text=_pdftotext(pdf_input)

    def _prompt_from_text(t):
        return f"""You rename scanned documents by extracting filename metadata.

Text from a scanned document:
{t}

Return ONLY valid JSON (no markdown, no extra text) with:
- date: best single date for the filename in YYYY-MM-DD (prefer date of service if this doc is about a service/appointment/delivery; otherwise prefer the document/issue date). null if unknown.
- date_basis: "service" | "document" | "unknown"
- provider: short issuer/vendor/provider/organization name (e.g., bank, utility, clinic, school). null if unknown.
- document_type: short type like "Statement", "Invoice", "Receipt", "Bill", "Report", "Letter", "Notice", "Contract", "Policy", "Form", "Tax Document", or similar. null if unknown.
- title: short human-readable title (max ~8 words). If the document already has a clear title, use it; otherwise infer one from content. null if unknown.
- confidence: number 0 to 1
"""

    def _prompt_for_vision(partial=None):
        partial=json.dumps(partial or {}, ensure_ascii=False)
        return f"""You rename scanned documents by extracting filename metadata.

If the user provides partial extracted JSON, use it as hints, but correct any obvious mistakes.

Partial extracted JSON hints (may be incomplete/wrong):
{partial}

Return ONLY valid JSON (no markdown, no extra text) with:
- date: best single date for the filename in YYYY-MM-DD (prefer date of service if this doc is about a service/appointment/delivery; otherwise prefer the document/issue date). null if unknown.
- date_basis: "service" | "document" | "unknown"
- provider: short issuer/vendor/provider/organization name. null if unknown.
- document_type: short type like "Statement", "Invoice", "Receipt", "Bill", "Report", "Letter", "Notice", "Contract", "Policy", "Form", "Tax Document", or similar. null if unknown.
- title: short human-readable title (max ~8 words). If the document already has a clear title, use it; otherwise infer one from content. null if unknown.
- confidence: number 0 to 1
"""

    def _vision_extract(partial_hint=None):
        for pages in [VISION_MAX_PAGES, max(1, VISION_MAX_PAGES-1), 1]:
            imgs=_render_pdf_to_images(pdf_input, max_pages=pages, dpi=VISION_DPI)
            prompt=_prompt_for_vision(partial_hint)
            content=[{"type":"text","text":prompt}] + [{"type":"image_url","image_url":{"url":u}} for u in imgs]
            out, err=_call_lm_studio([
                {"role":"system","content":"You extract metadata for naming scanned documents and output strict JSON only."},
                {"role":"user","content":content}
            ], max_tokens=450, timeout=120)
            if out:
                data=_extract_json_loose(out)
                if data: return data
                return None
            if not _is_context_overflow(err): return None
        return None

    # --- Text-first path
    if len(text) >= MIN_TEXT_CHARS:
        budgets=[7000, 4500, 2800, 1600]
        for b in budgets:
            t=_compact_text(text, b)
            out, err=_call_lm_studio([
                {"role":"system","content":"You extract metadata for naming scanned documents and output strict JSON only."},
                {"role":"user","content":_prompt_from_text(t)}
            ], max_tokens=350, timeout=60)

            if out:
                data=_extract_json_loose(out)
                if not data: return None, text

                # NEW: if too many unknowns, force vision and merge
                if _unknown_count(data) >= 2:
                    v=_vision_extract(partial_hint=data)
                    if v: data=_merge_fill_missing(data, v)

                return data, text

            if not _is_context_overflow(err):
                return None, text

    # --- Vision fallback (no/low text or persistent overflow)
    v=_vision_extract(partial_hint=None)
    if v: return v, text
    return None, text

# def extract_information(pdf_input):
#     text=_pdftotext(pdf_input)

#     def _prompt_from_text(t):
#         return f"""You rename scanned documents by extracting filename metadata.

# Text from a scanned document:
# {t}

# Return ONLY valid JSON (no markdown, no extra text) with:
# - date: best single date for the filename in YYYY-MM-DD (prefer date of service if this doc is about a service/appointment/delivery; otherwise prefer the document/issue date). null if unknown.
# - date_basis: "service" | "document" | "unknown"
# - provider: short issuer/vendor/provider/organization name (e.g., bank, utility, clinic, school). null if unknown.
# - document_type: short type like "Statement", "Invoice", "Receipt", "Bill", "Report", "Letter", "Notice", "Contract", "Policy", "Form", "Tax Document", or similar. null if unknown.
# - title: short human-readable title (max ~8 words). If the document already has a clear title, use it; otherwise infer one from content. null if you truly can't.
# - confidence: number 0 to 1
# """

#     if len(text) >= MIN_TEXT_CHARS:
#         budgets=[7000, 4500, 2800, 1600]
#         for b in budgets:
#             t=_compact_text(text, b)
#             out, err=_call_lm_studio([
#                 {"role":"system","content":"You extract metadata for naming scanned documents and output strict JSON only."},
#                 {"role":"user","content":_prompt_from_text(t)}
#             ], max_tokens=350, timeout=60)
#             if out:
#                 data=_extract_json_loose(out)
#                 if data: return data, text
#                 return None, text
#             if not _is_context_overflow(err): return None, text
#     try:
#         for pages in [VISION_MAX_PAGES, max(1, VISION_MAX_PAGES-1), 1]:
#             imgs=_render_pdf_to_images(pdf_input, max_pages=pages, dpi=VISION_DPI)
#             prompt=f"""You rename scanned documents by extracting filename metadata.

# Return ONLY valid JSON (no markdown, no extra text) with:
# - date: best single date for the filename in YYYY-MM-DD (prefer date of service if this doc is about a service/appointment/delivery; otherwise prefer the document/issue date). null if unknown.
# - date_basis: "service" | "document" | "unknown"
# - provider: short issuer/vendor/provider/organization name. null if unknown.
# - document_type: short type like "Statement", "Invoice", "Receipt", "Bill", "Report", "Letter", "Notice", "Contract", "Policy", "Form", "Tax Document", or similar. null if unknown.
# - title: short human-readable title (max ~8 words). If the document already has a clear title, use it; otherwise infer one from content. null if you truly can't.
# - confidence: number 0 to 1
# """
#             content=[{"type":"text","text":prompt}] + [{"type":"image_url","image_url":{"url":u}} for u in imgs]
#             out, err=_call_lm_studio([
#                 {"role":"system","content":"You extract metadata for naming scanned documents and output strict JSON only."},
#                 {"role":"user","content":content}
#             ], max_tokens=450, timeout=120)
#             if out:
#                 data=_extract_json_loose(out)
#                 if data: return data, text
#                 return None, text
#             if not _is_context_overflow(err): return None, text
#     except Exception:
#         return None, text
#     return None, text

def create_filename(info):
    d=_normalize_date(info.get("date"))
    if not d: d="UnknownDate"
    provider=_safe_filename(info.get("provider") or "Unknown Provider", 60)
    dt=_normalize_doc_type(info.get("document_type")) or "Document"
    title=_safe_filename(info.get("title") or "Untitled", 80)

    parts=[d, provider, dt, title]
    parts=[p for p in parts if p and p.strip()]
    base=" - ".join(parts).strip()
    base=_safe_filename(base, 180)
    return f"{base}.pdf"

def main():
    ap=argparse.ArgumentParser()
    ap.add_argument("pdf", help="Path to input PDF")
    ap.add_argument("--outdir", default=None, help="Destination directory (default: <input_dir>/processed)")
    ap.add_argument("--move", action="store_true", help="Move instead of copy")
    ap.add_argument("--dry-run", action="store_true", help="Print result, do not write file")
    ap.add_argument("--print-json", action="store_true", help="Print extracted JSON")
    args=ap.parse_args()

    pdf_input=args.pdf
    if not os.path.isfile(pdf_input):
        print("File not found:", pdf_input)
        return 2

    original_dir=os.path.dirname(os.path.abspath(pdf_input))
    outdir=args.outdir or os.path.join(original_dir, "processed")
    os.makedirs(outdir, exist_ok=True)

    info, raw_text=extract_information(pdf_input)
    if not info and raw_text:
        info=_heuristic_extract(raw_text)

    if not info:
        print("Failed to extract information.")
        return 1

    if args.print_json:
        print(json.dumps(info, indent=2, ensure_ascii=False))

    new_name=create_filename(info)
    dst=_unique_path(os.path.join(outdir, new_name))

    print("Proposed:", os.path.basename(dst))
    if args.dry_run: return 0

    if args.move:
        shutil.move(pdf_input, dst)
        print("Moved to:", dst)
    else:
        shutil.copy2(pdf_input, dst)
        print("Copied to:", dst)
    return 0

if __name__=="__main__":
    raise SystemExit(main())

